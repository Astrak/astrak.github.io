<!Doctype html>
<html>
	<head>
		<title>Point Cloud</title>
		<meta name='theme-color' content='#444'>
		<meta name='viewport' content='width=device-width,user-scalable=no'/>
		<!-- <script src=../../js/dat.gui.js></script> -->
		<script src=../../js/threer76.js></script>
		<script src=../../js/controls/OrbitControlsr76.js></script>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>
		<script>
			'use strict';
			
			var scene, renderer, camera, controls, pc;
			/*var gui, params = {
				blending : true,
				height : false,
			}*/

			
			setScene();

			function setScene () {
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( innerWidth, innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				loadPC( 'XYZ.txt' );

				setView();

				setUI();

				animate();
			}

			function setUI () {

			}

			function loadPC ( url ) {
				var xhr;
				if ( window.XMLHttpRequest || window.ActiveXObject ) {
					if ( window.ActiveXObject ) {
						try {
							xhr = new ActiveXObject("Msxml2.XMLHTTP");
						} catch(e) {
							xhr = new ActiveXObject("Microsoft.XMLHTTP");
						}
					} else {
						xhr = new XMLHttpRequest(); 
					}
				}
				xhr.onreadystatechange = function () {
					if ( xhr.readyState === 4 ) createMesh( xhr.response );
				};
				xhr.open( 'GET', url, true );
				xhr.send();
			}

			function createMesh ( d ) {
				var a = d.split( '\n' );
				var position = [];
				var shift = 0;
				for ( var i = 0 ; i < a.length ; i++ ) {
					var b = a[ i ].split( ' ' );
					if ( b[ 2 ] < 25 ) {
						shift ++;
						continue;
					}
					position[ ( i - shift ) * 3 ] = b[ 0 ];
					position[ ( i - shift ) * 3 + 1 ] = b[ 1 ];
					position[ ( i - shift ) * 3 + 2 ] = b[ 2 ];
				}
				console.info('rendering ' + position.length + ' points' );
				var g = new THREE.BufferGeometry();
				g.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( position ), 3 ) );
				pc = new THREE.Points( g, new THREE.ShaderMaterial({ 
					vertexShader : [
						'varying float height;',
						'varying float heightFactor;',
						'uniform float aspect;',
						'void main () {',
						'	height = position.z / 200.;',
						'	vec4 mvPosition = modelViewMatrix * vec4( position, 1. );',
						'	gl_Position = mvPosition * projectionMatrix;',
						'	float sizeAttenuation = aspect / length( mvPosition.xyz );',
						'	heightFactor = 100. * sin( height );',
						'	gl_PointSize = heightFactor * sizeAttenuation;',
						'}'
					].join( '\n' ),
					fragmentShader : [
						'varying float height;',
						'varying float heightFactor;',
						'void main () {',
						'	gl_FragColor = vec4( sin( ( height )  ), sin( ( height + 3.14 / 2. ) * 1.6 ), .0, heightFactor );',
						'}'
					].join( '\n'),
					uniforms : {
						aspect : { value : innerWidth / innerHeight }
					},
					transparent : true
					//blending : THREE.AdditiveBlending
				}));
				pc.rotation.x = - Math.PI / 2;
				pc.position.set( - 500, 0, 500 );
				scene.add( pc );
				camera.update = true;
			}

			function setView () {
				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, 1, 2000 );
				camera.position.set( 640, 476, -812);
				camera.update = false;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', function () { camera.update = true; }, false );
				controls.enableDamping = true;
				controls.dampingFactor = .05;
				controls.rotateSpeed = .07;

				window.addEventListener( 'resize', function () {
					camera.aspect = innerWidth / innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( innerWidth, innerHeight );
					camera.update = true;
				}, false );
			}

			function animate () {
				requestAnimationFrame(animate);
				controls.update();

				if ( camera.update ) {
					renderer.render( scene, camera );
					camera.update = false;
				}
			}
		</script>
		<script>
			//if ( 'serviceWorker' in navigator ) {
			//	navigator.serviceWorker.register( 'sw.js' ).then( function ( res ){
			//		var p = document.createElement( 'p' );
			//		p.innerHTML = 'Ce site est disponible hors-ligne. Cr√©ation du mesh...';
			//		p.style.cssText = ''+
			//			'position:absolute;'+
			//			'top:50%;left:50%;'+
			//			'width:200px;height:60px;'+
			//			'margin:-30px 0 0 -100px;'+
			//			'color:chocolate;'+
			//			'background:#222;'+
			//			'text-align:center;';
			//		document.body.appendChild( p );
			//		setTimeout( function () {
			//			document.body.removeChild( p );
			//		}, 4000 );
			//	}).catch( function ( err ) {
			//		console.info('the service worker failed to install, the app will not be available offline after this session');
			//	});
			//	var c = navigator.serviceWorker.controller
			//	console.log( c );
			//	if (c) c.addEventListener('message',function(e){console.log(e)});
			//}
		</script>
	</body>
</html>