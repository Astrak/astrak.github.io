<!DOCTYPE html>
<html>
	<head>
		<title>PBR Setup</title>
		<meta name='theme-color' content='#444'/>
		<meta name='viewport' content='width=device-width, user-scalable=no'/>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>

		<script src='../../js/dat.gui.js'></script>
		<script src='../../js/threer85dev.js'></script>
		<script src='../../js/controls/OrbitControlsr85.js'></script>
		<script src='../../js/loaders/RGBELoader.js'></script>
		<script src='../../js/loaders/HDRCubeTextureLoader.js'></script>
		<script src='../../js/pmrem/PMREMGenerator.js'></script>
		<script src='../../js/pmrem/PMREMCubeUVPacker.js'></script>
		<script>
			'use strict';
			
			var scene, camera, renderer, controls, light, mesh,
				pmremGen, pmremcubeuvpacker, hdrCubeTextureLoader, pmrem = null;

			var gui;

			var params = { 
				roughness : 1, 
				metalness : 1, 
				aoMapIntensity : 2.2,
				lightIntensity : 1,
				useUV2 : true
			};

			//custom MeshStandardMaterial where the AO map is sampled with the uv attribute, not uv2
			var material = new THREE.ShaderMaterial({

				uniforms: THREE.UniformsUtils.merge( [
					{
						color: { value: new THREE.Color( 0xeeeeee ) },
						opacity: { value: 1.0 },

						map: { value: null },
						offsetRepeat: { value: new THREE.Vector4( 0, 0, 1, 1 ) },

						specularMap: { value: null },
						alphaMap: { value: null },

						envMap: { value: null },
						flipEnvMap: { value: - 1 },
						reflectivity: { value: 1.0 },
						refractionRatio: { value: 0.98 }
					},
					THREE.UniformsLib.aomap,
					THREE.UniformsLib.lightmap,
					THREE.UniformsLib.emissivemap,
					THREE.UniformsLib.bumpmap,
					THREE.UniformsLib.normalmap,
					THREE.UniformsLib.displacementmap,
					THREE.UniformsLib.roughnessmap,
					THREE.UniformsLib.metalnessmap,
					THREE.UniformsLib.fog,
					THREE.UniformsLib.lights,
					{
						emissive: { value: new THREE.Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),

				vertexShader: ['#define PHYSICAL',
					'varying vec3 vViewPosition;',
					'#ifndef FLAT_SHADED',
					'	varying vec3 vNormal;',
					'#endif',
					'#include <common>',
					'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'	varying vec2 vUv;',
					'	uniform vec4 offsetRepeat;',
					'#endif',
					/*'#include <uv2_pars_vertex>',*/
					'#include <displacementmap_pars_vertex>',
					'#include <color_pars_vertex>',
					'#include <fog_pars_vertex>',
					'#include <morphtarget_pars_vertex>',
					'#include <skinning_pars_vertex>',
					'#include <shadowmap_pars_vertex>',
					'#include <specularmap_pars_fragment>',
					'#include <logdepthbuf_pars_vertex>',
					'#include <clipping_planes_pars_vertex>',
					'void main() {',
					'	#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'		vUv = uv * offsetRepeat.zw + offsetRepeat.xy;',
					'	#endif',
					/*'	#include <uv2_vertex>',*/
					'	#include <color_vertex>',
					'	#include <beginnormal_vertex>',
					'	#include <morphnormal_vertex>',
					'	#include <skinbase_vertex>',
					'	#include <skinnormal_vertex>',
					'	#include <defaultnormal_vertex>',
					'	#ifndef FLAT_SHADED',
					'		vNormal = normalize( transformedNormal );',
					'	#endif',
					'	#include <begin_vertex>',
					'	#include <displacementmap_vertex>',
					'	#include <morphtarget_vertex>',
					'	#include <skinning_vertex>',
					'	#include <project_vertex>',
					'	#include <logdepthbuf_vertex>',
					'	#include <clipping_planes_vertex>',
					'	vViewPosition = - mvPosition.xyz;',
					'	#include <worldpos_vertex>',
					'	#include <shadowmap_vertex>',
					'	#include <fog_vertex>',
					'}'].join( '\n' ),
				fragmentShader: ['#define PHYSICAL',
					'uniform vec3 diffuse;',
					'uniform vec3 emissive;',
					'uniform float roughness;',
					'uniform float metalness;',
					'uniform float opacity;',
					'#ifndef STANDARD',
					'	uniform float clearCoat;',
					'	uniform float clearCoatRoughness;',
					'#endif',
					'varying vec3 vViewPosition;',
					'#ifndef FLAT_SHADED',
					'	varying vec3 vNormal;',
					'#endif',
					'#include <common>',
					'#include <packing>',
					'#include <color_pars_fragment>',
					'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'	varying vec2 vUv;',
					'#endif',
					/*'#include <uv2_pars_fragment>',*/
					'#include <map_pars_fragment>',
					'#include <alphamap_pars_fragment>',
					'#include <aomap_pars_fragment>',
					'#include <lightmap_pars_fragment>',
					'#include <emissivemap_pars_fragment>',
					'#include <envmap_pars_fragment>',
					'#include <fog_pars_fragment>',
					'#include <bsdfs>',
					'#include <cube_uv_reflection_fragment>',
					'#include <lights_pars>',
					'#include <lights_physical_pars_fragment>',
					'#include <shadowmap_pars_fragment>',
					'#include <bumpmap_pars_fragment>',
					'#include <normalmap_pars_fragment>',
					'#include <roughnessmap_pars_fragment>',
					'#include <metalnessmap_pars_fragment>',
					'#include <logdepthbuf_pars_fragment>',
					'#include <clipping_planes_pars_fragment>',
					'void main() {',
					'	#include <clipping_planes_fragment>',
					'	vec4 diffuseColor = vec4( diffuse, opacity );',
					'	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',
					'	vec3 totalEmissiveRadiance = emissive;',
					'	#include <logdepthbuf_fragment>',
					'	#include <map_fragment>',
					'	#include <color_fragment>',
					'	#include <alphamap_fragment>',
					'	#include <alphatest_fragment>',
					'	#include <specularmap_fragment>',
					'	#include <roughnessmap_fragment>',
					'	#include <metalnessmap_fragment>',
					'	#include <normal_flip>',
					'	#include <normal_fragment>',
					'	#include <emissivemap_fragment>',
					'	#include <lights_physical_fragment>',
					'	#include <lights_template>',
					'	#ifdef USE_AOMAP',
					'		float ambientOcclusion = ( texture2D( aoMap, vUv ).r - 1.0 ) * aoMapIntensity + 1.0;',
					'		reflectedLight.indirectDiffuse *= ambientOcclusion;',
					'		#if defined( USE_ENVMAP ) && defined( PHYSICAL )',
					'			float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );',
					'			reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );',
					'		#endif',
					'	#endif',
					'	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',
					'	gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
					'	#include <premultiplied_alpha_fragment>',
					'	#include <tonemapping_fragment>',
					'	#include <encodings_fragment>',
					'	#include <fog_fragment>',
					'}'].join( '\n' )

			});

			setScene();

			function setScene () {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( innerWidth, innerHeight );
				renderer.gammaInput = renderer.gammaOutput = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 2;
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				loadIBLThenLoadMesh( 'hdr/', '.hdr' );

				setView();

				animate();

			}

			function update () {

				camera.update = true;

			}

			function loadIBLThenLoadMesh ( url, ext ) {
				//IBL
				hdrCubeTextureLoader = new THREE.HDRCubeTextureLoader().load( 
					THREE.UnsignedByteType, 
					(function (prefix, postfix) {
				    	return [
				    	  prefix + '1' + postfix, prefix + '3' + postfix,
				    	  prefix + '5' + postfix, prefix + '6' + postfix,
				    	  prefix + '2' + postfix, prefix + '4' + postfix
				    	];
					})( url, ext ),
					function ( t ) {
						console.time( 'pmrem generation time' );
						pmremGen = new THREE.PMREMGenerator( t );
						pmremGen.update( renderer );
						pmremcubeuvpacker = new THREE.PMREMCubeUVPacker( pmremGen.cubeLods );
						pmremcubeuvpacker.update( renderer );
						pmrem = pmremcubeuvpacker.CubeUVRenderTarget.texture;
						console.timeEnd( 'pmrem generation time' );

						//PMREM ok > load mesh to apply it as envMap later
						var tLoader = new THREE.TextureLoader();

						new THREE.JSONLoader().load( 'geometry.json', function( g ) {

							//mesh without UV2
							var geoWithoutUV2 = new THREE.BufferGeometry().fromGeometry(g);

							material.uniforms.envMap.value = pmrem;
							material.uniforms.metalness.value = 1; 
							material.uniforms.roughness.value = 1;
							material.uniforms.metalnessMap.value = tLoader.load( 'tex/DefaultMaterial_Metallic.png', update );
							material.uniforms.roughnessMap.value = tLoader.load( 'tex/DefaultMaterial_Roughness.png', update );
							material.uniforms.map.value = tLoader.load( 'tex/DefaultMaterial_Base_Color.png', update );
							material.uniforms.aoMap.value = tLoader.load( 'tex/DefaultMaterial_Mixed_AO.png', update );
							material.uniforms.aoMapIntensity.value = params.aoMapIntensity;
							material.uniforms.normalMap.value = tLoader.load( 'tex/DefaultMaterial_Normal.png', update );

							window.meshWithoutUV2 = new THREE.Mesh( geoWithoutUV2, material );

							//mesh with UV2
							var geoWithUV2 = geoWithoutUV2.clone();
							geoWithUV2.addAttribute( 'uv2', geoWithUV2.attributes.uv );

							window.meshWithUV2 = new THREE.Mesh(
								geoWithUV2, 
								new THREE.MeshStandardMaterial({
									envMap : pmrem,
									metalness : 1, 
									roughness : 1,
									metalnessMap : material.uniforms.metalnessMap.value,
									roughnessMap : material.uniforms.roughnessMap.value,
									map : material.uniforms.map.value,
									aoMap : material.uniforms.aoMap.value,
									aoMapIntensity : params.aoMapIntensity,
									normalMap : material.uniforms.normalMap.value
								}));

							scene.add( meshWithUV2 );
							
							mesh = meshWithUV2;

							camera.update = true;

							setLighting();

						});

						//controller
						gui = new dat.GUI();

						var guiboth = gui.add( params, 'useUV2' ); guiboth.onChange( function () {

							if ( params.useUV2 ) {

								scene.remove( meshWithoutUV2 );
								scene.add( meshWithUV2 );
							
								mesh = meshWithUV2;

							} else {

								scene.remove( meshWithUV2 );
								scene.add( meshWithoutUV2 );

								mesh = meshWithoutUV2;
 
							}

							camera.update = true;

						});
						var guiRough = gui.add( params, 'roughness', 0, 1 ); guiRough.onChange( function () {
							meshWithUV2.material.roughness = material.uniforms.roughness.value = params.roughness;
							camera.update = true;
						});
						var guiMetal = gui.add( params, 'metalness', 0, 1 ); guiMetal.onChange( function () {
							meshWithUV2.material.metalness = material.uniforms.metalness.value = params.metalness;
							camera.update = true;
						});
						var guiAO = gui.add( params, 'aoMapIntensity', 0, 3 ); guiAO.onChange( function () {
							meshWithUV2.material.aoMapIntensity = material.uniforms.aoMapIntensity.value = params.aoMapIntensity;
							camera.update = true;
						});

						camera.update = true;
					}
				);
			}

			function setLighting () {

				light = new THREE.DirectionalLight( 0xffffff, params.lightIntensity, 20 );
				light.position.set( 5, 0, 0 );
				scene.add( light );

				var guilight = gui.add( params, 'lightIntensity', 0, 4 ); guilight.onChange( function () {
					light.intensity = params.lightIntensity;
					camera.update = true;
				});

				//shadow casting
				light.castShadow = true;
				meshWithUV2.castShadow = meshWithUV2.receiveShadow = true;
				meshWithoutUV2.castShadow = meshWithoutUV2.receiveShadow = true;
				light.shadow.mapSize.set( 2048, 2048 );
				light.shadow.camera.top = light.shadow.camera.right = 2;
				light.shadow.camera.bottom = light.shadow.camera.left = -2;
				light.shadow.bias = .00002;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.autoUpdate = false;
				renderer.shadowMap.needsUpdate = true;

			}

			function setView () {

				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, .2, 200 );
				camera.position.set( 5, 5, 5 );
				camera.update = true;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', function () { camera.update = true; } );
				controls.enableDamping = true;
				controls.dampingFactor = .1;
				controls.rotateSpeed = .07;

				window.addEventListener( 'resize', resize, false );

			}

			function resize () {

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( innerWidth, innerHeight );
				camera.update = true;

			}

			function animate () {

				requestAnimationFrame( animate );
				controls.update();

				if ( camera.update ) {
					renderer.render( scene, camera );
					camera.update = false;
				}

			}
		</script>
	</body>
</html>