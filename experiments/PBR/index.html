<!DOCTYPE html>
<html>
	<head>
		<title>PBR Setup</title>
		<meta name='theme-color' content='#444'/>
		<meta name='viewport' content='width=device-width, user-scalable=no'/>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>

		<script src='../../js/dat.gui.js'></script>
		<script src='../../js/threer85dev.js'></script>
		<script src='../../js/controls/OrbitControlsr85.js'></script>
		<script src='../../js/loaders/RGBELoader.js'></script>
		<script src='../../js/loaders/HDRCubeTextureLoader.js'></script>
		<script src='../../js/pmrem/PMREMGenerator.js'></script>
		<script src='../../js/pmrem/PMREMCubeUVPacker.js'></script>
		<script>
			'use strict';
			
			var scene, camera, renderer, controls, light, mesh,
				pmremGen, pmremcubeuvpacker, hdrCubeTextureLoader, pmrem = null;

			var gui;

			var params = { 
				roughness : 1, 
				metalness : 1,
				aoMapIntensity : 2.2,
				lightIntensity : 1,
				useUV2 : true
			};

			//custom MeshStandardMaterial where the AO map is sampled with the uv attribute, not uv2
			var material = new THREE.ShaderMaterial({

				uniforms: THREE.UniformsUtils.merge( [
					{
						color: { value: new THREE.Color( 0xeeeeee ) },
						opacity: { value: 1.0 },

						map: { value: null },
						offsetRepeat: { value: new THREE.Vector4( 0, 0, 1, 1 ) },

						specularMap: { value: null },
						alphaMap: { value: null },

						envMap: { value: null },
						flipEnvMap: { value: - 1 },
						reflectivity: { value: 1.0 },
						refractionRatio: { value: 0.98 }
					},
					THREE.UniformsLib.aomap,
					THREE.UniformsLib.lightmap,
					THREE.UniformsLib.emissivemap,
					THREE.UniformsLib.bumpmap,
					THREE.UniformsLib.normalmap,
					THREE.UniformsLib.displacementmap,
					THREE.UniformsLib.roughnessmap,
					THREE.UniformsLib.metalnessmap,
					THREE.UniformsLib.fog,
					THREE.UniformsLib.lights,
					{
						emissive: { value: new THREE.Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),

				light: true,
				fog: true,

				vertexShader: ['#define PHYSICAL',
					'varying vec3 vViewPosition;',
					'#ifndef FLAT_SHADED',
					'	varying vec3 vNormal;',
					'#endif',
					'#include <common>',
					'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'	varying vec2 vUv;',
					'	uniform vec4 offsetRepeat;',
					'#endif',
					/*'#include <uv2_pars_vertex>',*/
					'#include <displacementmap_pars_vertex>',
					'#include <color_pars_vertex>',
					'#include <fog_pars_vertex>',
					'#include <morphtarget_pars_vertex>',
					'#include <skinning_pars_vertex>',
					'#include <shadowmap_pars_vertex>',
					'#include <specularmap_pars_fragment>',
					'#include <logdepthbuf_pars_vertex>',
					'#include <clipping_planes_pars_vertex>',
					'void main() {',
					'	#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'		vUv = uv * offsetRepeat.zw + offsetRepeat.xy;',
					'	#endif',
					/*'	#include <uv2_vertex>',*/
					'	#include <color_vertex>',
					'	#include <beginnormal_vertex>',
					'	#include <morphnormal_vertex>',
					'	#include <skinbase_vertex>',
					'	#include <skinnormal_vertex>',
					'	#include <defaultnormal_vertex>',
					'	#ifndef FLAT_SHADED',
					'		vNormal = normalize( transformedNormal );',
					'	#endif',
					'	#include <begin_vertex>',
					'	#include <displacementmap_vertex>',
					'	#include <morphtarget_vertex>',
					'	#include <skinning_vertex>',
					'	#include <project_vertex>',
					'	#include <logdepthbuf_vertex>',
					'	#include <clipping_planes_vertex>',
					'	vViewPosition = - mvPosition.xyz;',
					'	#include <worldpos_vertex>',
					'	#include <shadowmap_vertex>',
					'	#include <fog_vertex>',
					'}'].join( '\n' ),
				fragmentShader: ['#define PHYSICAL',
					'uniform vec3 diffuse;',
					'uniform vec3 emissive;',
					'uniform float roughness;',
					'uniform float metalness;',
					'uniform float opacity;',
					'#ifndef STANDARD',
					'	uniform float clearCoat;',
					'	uniform float clearCoatRoughness;',
					'#endif',
					'varying vec3 vViewPosition;',
					'#ifndef FLAT_SHADED',
					'	varying vec3 vNormal;',
					'#endif',
					'#include <common>',
					'#include <packing>',
					'#include <color_pars_fragment>',
					'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_AOMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',
					'	varying vec2 vUv;',
					'#endif',
					/*'#include <uv2_pars_fragment>',*/
					'#include <map_pars_fragment>',
					'#include <alphamap_pars_fragment>',
					'#include <aomap_pars_fragment>',
					'#include <lightmap_pars_fragment>',
					'#include <emissivemap_pars_fragment>',
					'#include <envmap_pars_fragment>',
					'#include <fog_pars_fragment>',
					'#include <bsdfs>',
					'#include <cube_uv_reflection_fragment>',
					'#include <lights_pars>',
					'#include <lights_physical_pars_fragment>',
					'#include <shadowmap_pars_fragment>',
					'#include <bumpmap_pars_fragment>',
					'#include <normalmap_pars_fragment>',
					'#include <roughnessmap_pars_fragment>',
					'#include <metalnessmap_pars_fragment>',
					'#include <logdepthbuf_pars_fragment>',
					'#include <clipping_planes_pars_fragment>',
					'void main() {',
					'	#include <clipping_planes_fragment>',
					'	vec4 diffuseColor = vec4( diffuse, opacity );',
					'	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',
					'	vec3 totalEmissiveRadiance = emissive;',
					'	#include <logdepthbuf_fragment>',
					'	#include <map_fragment>',
					'	#include <color_fragment>',
					'	#include <alphamap_fragment>',
					'	#include <alphatest_fragment>',
					'	#include <specularmap_fragment>',
					'	#include <roughnessmap_fragment>',
					'	#include <metalnessmap_fragment>',
					'	#include <normal_flip>',
					'	#include <normal_fragment>',
					'	#include <emissivemap_fragment>',
					'	#include <lights_physical_fragment>',
					'	#include <lights_template>',
					'	#ifdef USE_AOMAP',
					'		float ambientOcclusion = ( texture2D( aoMap, vUv ).r - 1.0 ) * aoMapIntensity + 1.0;',
					'		reflectedLight.indirectDiffuse *= ambientOcclusion;',
					'		#if defined( USE_ENVMAP ) && defined( PHYSICAL )',
					'			float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );',
					'			reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );',
					'		#endif',
					'	#endif',
					'	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',
					'	gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
					'	#include <premultiplied_alpha_fragment>',
					'	#include <tonemapping_fragment>',
					'	#include <encodings_fragment>',
					'	#include <fog_fragment>',
					'}'].join( '\n' )

			});

			setScene();

			function setScene () {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( innerWidth, innerHeight );
				renderer.gammaInput = renderer.gammaOutput = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 2;
				document.body.appendChild( renderer.domElement );

				var disclaimer = document.createElement( 'p' );
				disclaimer.textContent = "When 'useUV2' is on, the AO map is sampled using the varying 'vUv2' in the fragment shader as it uses to, and the geometry used has an uv2 attribute. The render fails in Edge and IE11. When 'useUV2' is turned off, the fragment shader uses the varying 'vUv' and the mesh uses a geometry with no uv2 attribute.";
				disclaimer.style.cssText = 'position:absolute;top:0;width:100%;text-align:center;font-family:monospace;color:#fff;';
				document.body.appendChild( disclaimer );

				scene = new THREE.Scene();

				loadIBLThenLoadMesh( 'hdr/', '.hdr' );

				setView();

				animate();

			}

			function update () {

				camera.update = true;

			}

			function loadIBLThenLoadMesh ( url, ext ) {
				//IBL
				hdrCubeTextureLoader = new THREE.HDRCubeTextureLoader().load( 
					THREE.UnsignedByteType, 
					(function (prefix, postfix) {
				    	return [
				    	  prefix + '1' + postfix, prefix + '3' + postfix,
				    	  prefix + '5' + postfix, prefix + '6' + postfix,
				    	  prefix + '2' + postfix, prefix + '4' + postfix
				    	];
					})( url, ext ),
					function ( t ) {
						console.time( 'pmrem generation time' );
						pmremGen = new THREE.PMREMGenerator( t );
						pmremGen.update( renderer );
						pmremcubeuvpacker = new THREE.PMREMCubeUVPacker( pmremGen.cubeLods );
						pmremcubeuvpacker.update( renderer );
						pmrem = pmremcubeuvpacker.CubeUVRenderTarget.texture;
						console.timeEnd( 'pmrem generation time' );

						//PMREM ok > load mesh to apply it as envMap later
						var tLoader = new THREE.TextureLoader();

						new THREE.JSONLoader().load( 'geometry.json', function( g ) {

							//mesh without UV2
							var geoWithoutUV2 = new THREE.BufferGeometry().fromGeometry(g);

							material.uniforms.envMap.value = pmrem;
							material.uniforms.metalness.value = 1; 
							material.uniforms.roughness.value = 1;
							material.uniforms.metalnessMap.value = tLoader.load( 'tex/DefaultMaterial_Metallic.png', update );
							material.uniforms.roughnessMap.value = tLoader.load( 'tex/DefaultMaterial_Roughness.png', update );
							material.uniforms.map.value = tLoader.load( 'tex/DefaultMaterial_Base_Color.png', update );
							material.uniforms.aoMap.value = tLoader.load( 'tex/DefaultMaterial_Mixed_AO.png', update );
							material.uniforms.aoMapIntensity.value = params.aoMapIntensity;
							material.uniforms.normalMap.value = tLoader.load( 'tex/DefaultMaterial_Normal.png', update );

							window.meshWithoutUV2 = new THREE.Mesh( geoWithoutUV2, material );

							//mesh with UV2
							var geoWithUV2 = geoWithoutUV2.clone();
							geoWithUV2.addAttribute( 'uv2', geoWithUV2.attributes.uv );

							window.meshWithUV2 = new THREE.Mesh(
								geoWithUV2, 
								new THREE.MeshStandardMaterial({
									envMap : pmrem,
									metalness : 1, 
									roughness : 1,
									metalnessMap : material.uniforms.metalnessMap.value,
									roughnessMap : material.uniforms.roughnessMap.value,
									map : material.uniforms.map.value,
									aoMap : material.uniforms.aoMap.value,
									aoMapIntensity : params.aoMapIntensity,
									normalMap : material.uniforms.normalMap.value
								}));

							scene.add( meshWithUV2 );
							
							mesh = meshWithUV2;

							camera.update = true;

							setLighting();

						});

						//controller
						gui = new dat.GUI();

						var guiboth = gui.add( params, 'useUV2' ); guiboth.onChange( function () {

							if ( params.useUV2 ) {

								scene.remove( meshWithoutUV2 );
								scene.add( meshWithUV2 );
							
								mesh = meshWithUV2;

							} else {

								scene.remove( meshWithUV2 );
								scene.add( meshWithoutUV2 );

								mesh = meshWithoutUV2;
 
							}

							camera.update = true;

						});
						var guiRough = gui.add( params, 'roughness', 0, 1 ); guiRough.onChange( function () {
							meshWithUV2.material.roughness = material.uniforms.roughness.value = params.roughness;
							camera.update = true;
						});
						var guiMetal = gui.add( params, 'metalness', 0, 1 ); guiMetal.onChange( function () {
							meshWithUV2.material.metalness = material.uniforms.metalness.value = params.metalness;
							camera.update = true;
						});
						var guiAO = gui.add( params, 'aoMapIntensity', 0, 3 ); guiAO.onChange( function () {
							meshWithUV2.material.aoMapIntensity = material.uniforms.aoMapIntensity.value = params.aoMapIntensity;
							camera.update = true;
						});

						camera.update = true;
					}
				);
			}

			function setLighting () {

				light = new THREE.DirectionalLight( 0xffffff, params.lightIntensity, 20 );
				light.position.set( 5, 0, 0 );
				scene.add( light );

				var guilight = gui.add( params, 'lightIntensity', 0, 4 ); guilight.onChange( function () {
					light.intensity = params.lightIntensity;
					camera.update = true;
				});

				//shadow casting
				light.castShadow = true;
				meshWithUV2.castShadow = meshWithUV2.receiveShadow = true;
				meshWithoutUV2.castShadow = meshWithoutUV2.receiveShadow = true;
				light.shadow.mapSize.set( 2048, 2048 );
				light.shadow.camera.top = light.shadow.camera.right = 2;
				light.shadow.camera.bottom = light.shadow.camera.left = -2;
				light.shadow.bias = .00002;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.autoUpdate = false;
				renderer.shadowMap.needsUpdate = true;

			}

			function setView () {

				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, .2, 200 );
				camera.position.set( 5, 5, 5 );
				camera.update = true;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', function () { camera.update = true; } );
				controls.enableDamping = true;
				controls.dampingFactor = .1;
				controls.rotateSpeed = .07;

				window.addEventListener( 'resize', resize, false );

			}

			function resize () {

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( innerWidth, innerHeight );
				camera.update = true;

			}

			function animate () {

				requestAnimationFrame( animate );
				controls.update();

				if ( camera.update ) {
					renderer.render( scene, camera );
					camera.update = false;
				}

			}
		</script>
	</body>
</html>