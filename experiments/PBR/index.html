<!DOCTYPE html>
<html>
	<head>
		<title>PBR Setup</title>
		<meta name='theme-color' content='#444'/>
		<meta name='viewport' content='width=device-width, user-scalable=no'/>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>

		<script src='../../js/dat.gui.js'></script>
		<script src='../../js/threer85dev.js'></script>
		<script src='../../js/controls/OrbitControlsr85.js'></script>
		<script src='../../js/loaders/RGBELoader.js'></script>
		<script src='../../js/loaders/HDRCubeTextureLoader.js'></script>
		<script src='../../js/pmrem/PMREMGenerator.js'></script>
		<script src='../../js/pmrem/PMREMCubeUVPacker.js'></script>
		<script src='../../js/pmrem/PMREMCubeUVPacker.js'></script>
		<script src='../../js/LoadScreen.js'></script>
		<script>
			'use strict';
			
			var scene, camera, renderer, controls, light, mesh;

			var gui;

			var params = { 
				roughness : 1, 
				metalness : 1,
				aoMapIntensity : 2.2,
				lightIntensity : 1
			};

			var ASSETS = {
				textures: {
					envMap: {
						path: ( function ( a, b ) {
					    	return [
					    	  a + '1' + b, a + '3' + b,
					    	  a + '5' + b, a + '6' + b,
					    	  a + '2' + b, a + '4' + b
					    	];
						} )( 'hdr/', '.hdr' ),
						fileSize: 4898,
						toPMREM: true
					},
					roughness: { path: 'tex/DefaultMaterial_Roughness.png', fileSize: 1100 },
					metalness: { path: 'tex/DefaultMaterial_Metallic.png', fileSize: 17 },
					albedo: { path: 'tex/DefaultMaterial_Base_Color.png', fileSize: 2500 },
					ao: { path: 'tex/DefaultMaterial_Mixed_AO.png', fileSize: 1500 },
					normalMap: { path: 'tex/DefaultMaterial_Normal.png', fileSize: 736 }
				},
				geometries: {
					shape: {
						path: 'geometry.json',
						fileSize: 46,
						toBufferGeometry: true,
						onComplete: function ( g ) {
							g.addAttribute( 'uv2', g.attributes.uv );
						}
					}
				},
				objects: {
					object: {
						geometry: 'shape',
						material: new THREE.MeshStandardMaterial({
							roughness: params.roughness,
							metalness: params.metalness,
							aoMapIntensity: params.aoMapIntensity
						}),
						map: 'albedo',
						envMap: 'envMap',
						roughnessMap: 'roughness',
						metalnessMap: 'metalness',
						aoMap: 'ao',
						normalMap: 'normalMap',
						castShadow: true,
						receiveShadow: true
					}
				}
			};

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( innerWidth, innerHeight );
			renderer.gammaInput = renderer.gammaOutput = true;
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.toneMappingExposure = 2;
			document.body.appendChild( renderer.domElement );

			var ls = new LoadScreen( renderer, { type: 'circular-rotate' } ).onComplete( setScene ).start( ASSETS );

			function setScene () {

				var disclaimer = document.createElement( 'p' );
				disclaimer.textContent = "In IE11 and Edge : when UV1 is used to sample the aomap instead of uv2, the render is correct.";
				disclaimer.style.cssText = 'position:absolute;top:0;width:100%;text-align:center;font-family:monospace;color:#fff;';
				document.body.appendChild( disclaimer );

				scene = new THREE.Scene();

				mesh = ASSETS.objects.object;

				scene.add( mesh );

				//controller
				gui = new dat.GUI();
				var guiRough = gui.add( params, 'roughness', 0, 1 ); guiRough.onChange( function () {
					mesh.material.roughness = params.roughness;
					camera.update = true;
				});
				var guiMetal = gui.add( params, 'metalness', 0, 1 ); guiMetal.onChange( function () {
					mesh.material.metalness = params.metalness;
					camera.update = true;
				});
				var guiAO = gui.add( params, 'aoMapIntensity', 0, 3 ); guiAO.onChange( function () {
					mesh.material.aoMapIntensity = params.aoMapIntensity;
					camera.update = true;
				});

				setLighting();

				setView();

				camera.update = true;

				ls.remove( animate );

			}

			function setLighting () {

				light = new THREE.DirectionalLight( 0xffffff, params.lightIntensity, 20 );
				light.position.set( 5, 0, 0 );
				scene.add( light );

				var guilight = gui.add( params, 'lightIntensity', 0, 4 ); guilight.onChange( function () {
					light.intensity = params.lightIntensity;
					camera.update = true;
				});

				//shadow casting
				light.castShadow = true;
				mesh.castShadow = mesh.receiveShadow = true;
				light.shadow.mapSize.set( 2048, 2048 );
				light.shadow.camera.top = light.shadow.camera.right = 2;
				light.shadow.camera.bottom = light.shadow.camera.left = -2;
				light.shadow.bias = .00002;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.autoUpdate = false;
				renderer.shadowMap.needsUpdate = true;

			}

			function setView () {

				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, .2, 200 );
				camera.position.set( 5, 5, 5 );
				camera.update = true;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', function () { camera.update = true; } );
				controls.enableDamping = true;
				controls.dampingFactor = .1;
				controls.rotateSpeed = .07;

				window.addEventListener( 'resize', resize, false );

			}

			function resize () {

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( innerWidth, innerHeight );
				camera.update = true;

			}

			function animate () {

				requestAnimationFrame( animate );
				controls.update();

				if ( camera.update ) {
					renderer.render( scene, camera );
					camera.update = false;
				}

			}
		</script>
	</body>
</html>