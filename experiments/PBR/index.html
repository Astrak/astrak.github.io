<!DOCTYPE html>
<html>
	<head>
		<title>PBR Setup</title>
		<meta name='theme-color' content='#444'/>
		<meta name='viewport' content='width=device-width, user-scalable=no'/>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>

		<script src='../../js/dat.gui.js'></script>
		<script src='../../js/threer85dev.js'></script>
		<script src='../../js/controls/OrbitControlsr85.js'></script>
		<script src='../../js/loaders/RGBELoader.js'></script>
		<script src='../../js/loaders/HDRCubeTextureLoader.js'></script>
		<script src='../../js/pmrem/PMREMGenerator.js'></script>
		<script src='../../js/pmrem/PMREMCubeUVPacker.js'></script>
		<script>
			'use strict';
			
			var scene, camera, renderer, controls, light, mesh,
				pmremGen, pmremcubeuvpacker, hdrCubeTextureLoader, pmrem = null;

			var gui;

			var params = { 
				roughness : 1, 
				metalness : 1,
				aoMapIntensity : 2.2,
				lightIntensity : 1
			};

			setScene();

			function setScene () {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( innerWidth, innerHeight );
				renderer.gammaInput = renderer.gammaOutput = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 2;
				document.body.appendChild( renderer.domElement );

				var disclaimer = document.createElement( 'p' );
				disclaimer.textContent = "In IE11 and Edge : when UV1 is used to sample the aomap instead of uv2, the render is correct.";
				disclaimer.style.cssText = 'position:absolute;top:0;width:100%;text-align:center;font-family:monospace;color:#fff;';
				document.body.appendChild( disclaimer );

				scene = new THREE.Scene();

				loadIBLThenLoadMesh( 'hdr/', '.hdr' );

				setView();

				animate();

			}

			function update () {

				camera.update = true;

			}

			function loadIBLThenLoadMesh ( url, ext ) {
				//IBL
				hdrCubeTextureLoader = new THREE.HDRCubeTextureLoader().load( 
					THREE.UnsignedByteType, 
					(function (prefix, postfix) {
				    	return [
				    	  prefix + '1' + postfix, prefix + '3' + postfix,
				    	  prefix + '5' + postfix, prefix + '6' + postfix,
				    	  prefix + '2' + postfix, prefix + '4' + postfix
				    	];
					})( url, ext ),
					function ( t ) {
						console.time( 'pmrem generation time' );
						pmremGen = new THREE.PMREMGenerator( t );
						pmremGen.update( renderer );
						pmremcubeuvpacker = new THREE.PMREMCubeUVPacker( pmremGen.cubeLods );
						pmremcubeuvpacker.update( renderer );
						pmrem = pmremcubeuvpacker.CubeUVRenderTarget.texture;
						console.timeEnd( 'pmrem generation time' );

						//PMREM ok > load mesh to apply it as envMap later
						var tLoader = new THREE.TextureLoader();

						new THREE.JSONLoader().load( 'geometry.json', function( g ) {

							//mesh with UV2
							var geo = new THREE.BufferGeometry().fromGeometry( g );
							geo.addAttribute( 'uv2', geo.attributes.uv );

							window.meshWithUV2 = new THREE.Mesh(
								geo, 
								new THREE.MeshStandardMaterial({
									envMap : pmrem,
									metalness : 1, 
									roughness : 1,
									metalnessMap : tLoader.load( 'tex/DefaultMaterial_Metallic.png', update ),
									roughnessMap : tLoader.load( 'tex/DefaultMaterial_Roughness.png', update ),
									map : tLoader.load( 'tex/DefaultMaterial_Base_Color.png', update ),
									aoMap : tLoader.load( 'tex/DefaultMaterial_Mixed_AO.png', update ),
									aoMapIntensity : params.aoMapIntensity,
									normalMap : tLoader.load( 'tex/DefaultMaterial_Normal.png', update )
								}));

							scene.add( meshWithUV2 );
							
							mesh = meshWithUV2;

							camera.update = true;

							setLighting();

						});

						//controller
						gui = new dat.GUI();
						var guiRough = gui.add( params, 'roughness', 0, 1 ); guiRough.onChange( function () {
							meshWithUV2.material.roughness = params.roughness;
							camera.update = true;
						});
						var guiMetal = gui.add( params, 'metalness', 0, 1 ); guiMetal.onChange( function () {
							meshWithUV2.material.metalness = params.metalness;
							camera.update = true;
						});
						var guiAO = gui.add( params, 'aoMapIntensity', 0, 3 ); guiAO.onChange( function () {
							meshWithUV2.material.aoMapIntensity = params.aoMapIntensity;
							camera.update = true;
						});

						camera.update = true;
					}
				);
			}

			function setLighting () {

				light = new THREE.DirectionalLight( 0xffffff, params.lightIntensity, 20 );
				light.position.set( 5, 0, 0 );
				scene.add( light );

				var guilight = gui.add( params, 'lightIntensity', 0, 4 ); guilight.onChange( function () {
					light.intensity = params.lightIntensity;
					camera.update = true;
				});

				//shadow casting
				light.castShadow = true;
				meshWithUV2.castShadow = meshWithUV2.receiveShadow = true;
				light.shadow.mapSize.set( 2048, 2048 );
				light.shadow.camera.top = light.shadow.camera.right = 2;
				light.shadow.camera.bottom = light.shadow.camera.left = -2;
				light.shadow.bias = .00002;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.autoUpdate = false;
				renderer.shadowMap.needsUpdate = true;

			}

			function setView () {

				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, .2, 200 );
				camera.position.set( 5, 5, 5 );
				camera.update = true;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', function () { camera.update = true; } );
				controls.enableDamping = true;
				controls.dampingFactor = .1;
				controls.rotateSpeed = .07;

				window.addEventListener( 'resize', resize, false );

			}

			function resize () {

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( innerWidth, innerHeight );
				camera.update = true;

			}

			function animate () {

				requestAnimationFrame( animate );
				controls.update();

				if ( camera.update ) {
					renderer.render( scene, camera );
					camera.update = false;
				}

			}
		</script>
	</body>
</html>