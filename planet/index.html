<!DOCTYPE html>
<html>
	<head>
		<title>PLANET SHADER V1</title>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
		</style>
	</head>
	<body>

	<script src='../libs/three.js'></script>
	<script src='../libs/controls/OrbitControls.js'></script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying float shading;
			void main() {
				vUv = uv;
				shading = 2. * dot( normal, vec3( 1., 0., 0.) );
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform float time;
			uniform sampler2D noiseTex;
			uniform sampler2D cloudTex1;
			uniform sampler2D cloudTex2;
			uniform sampler2D earthTex;
			varying vec2 vUv;
			varying float shading;
			float hash( vec2 p ){
				float h = dot(p,vec2(127.1,311.7));
			    return -1.0 + 2.0*fract(sin(h)*43758.5453123);
			}
			float noise( in vec2 p ){
				vec2 i = floor( p );
				vec2 f = fract( p );
				vec2 u = f*f*(3.0-2.0*f);
			    return mix( mix( hash( i + vec2(0.0,0.0) ), 
			                     hash( i + vec2(1.0,0.0) ), u.x),
			                mix( hash( i + vec2(0.0,1.0) ), 
			                     hash( i + vec2(1.0,1.0) ), u.x), u.y);
			}
			float wind(in vec2 coord){
				float value = noise(coord / 64.) * 64.;
				value += noise(coord / 32.) * 32.;
				value += noise(coord / 16.) * 16.;
				value += noise(coord / 8.) * 8.;
				value += noise(coord / 4.) * 4.;
	
			    return value;
			}
			void main() {
				vec2 crd = vUv*vec2(2.,1.)+vec2(-time,.0);
				float noise1 = .02*wind(300.*crd);
				float noise2 = .02*wind(1000.*crd);
				vec2 uv = mod( vUv + vec2( - .2*time, .0 )+vec2(.001*noise1*noise2), 1. ) * vec2(2.,1.);
				vec4 mainCol;
				if(uv.x > 1. ) {
					mainCol = 2. * texture2D( cloudTex2, uv - vec2(1.,0.) );
				} else {
					mainCol = 2. * texture2D( cloudTex1, uv );					
				}
				mainCol = clamp( mainCol, 0., 1. );
				mainCol += texture2D( earthTex, vUv );
				mainCol += 1.6 * vec4(1.,.3,.0,0) * max(0.,.6-shading);

				gl_FragColor = clamp( mainCol * shading, 0., 1.);
			}
		</script>

		<script>
			'use strict';
			
			var scene, renderer, camera, controls, clouds;
			var textureLoader = new THREE.TextureLoader();
			
			setScene();
			animate();

			function setScene(){
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( innerWidth, innerHeight );
				document.body.appendChild( renderer.domElement );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 70, innerWidth / innerHeight, .1, 50 );
				camera.position.z = 6;
				camera.update = false;
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = .05;
				controls.rotateSpeed = .07;

				addPlanet();

				setLighting();
			}

			function setLighting () {
				var sun = new THREE.DirectionalLight(0xffffff, 3);
				sun.position.set(10,0,0);
				scene.add( sun );
			}

			function addPlanet () {
				var uniforms = {
					time: { type: "f", value: 1.0 },
					noiseTex: { type: "t", value: textureLoader.load( "noise.png" ) },
					earthTex: { type: "t", value: textureLoader.load( "MR.jpg" ) },
					cloudTex1: { type: "t", value: textureLoader.load( "clouds1.jpg" ) },
					cloudTex2: { type: "t", value: textureLoader.load( "clouds2.jpg" ) }
				};
				uniforms.cloudTex1.value.minFilter=THREE.LinearFilter;
				uniforms.cloudTex2.value.minFilter=THREE.LinearFilter;
				var sphere=new THREE.SphereBufferGeometry(3, 300, 30);
				var material = new THREE.ShaderMaterial({
					vertexShader:document.getElementById('vertexShader').textContent,
					fragmentShader:document.getElementById('fragmentShader').textContent,
					uniforms:uniforms,
					transparent:true
				});


				clouds=new THREE.Mesh(sphere, material);
				scene.add(clouds);
			}

			function animate (t) {
				requestAnimationFrame(animate);
				controls.update();
				if ( clouds.hasOwnProperty('material') ) clouds.material.uniforms.time.value=.000001*t;
				renderer.render(scene, camera)
			}
		</script>
	</body>
</html>