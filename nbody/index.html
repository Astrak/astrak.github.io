<!DOCTYPE html>
<html>
<head>
	<title>TITLE</title>
</head>
<body style='margin:0;overflow:hidden;'>
<script src='../libs/threer72.js'></script>
<script src='../libs/controls/TrackballControls.js'></script>

<!--display shaders -->
<script id='vs' type='x-shader/x-vertex'>
	uniform sampler2D posTex;
	uniform float pointSize;
	uniform float pixelRatio;
	varying float blueColor;
	varying float gas;
	void main(){
		vec4 vPosition=texture2D(posTex,position.xy);
		vec4 mvPosition=modelViewMatrix*vPosition;
		float l=length(vPosition);

		blueColor=max(.32,.0065*l);
		gas=max(.0,sin(-l/20.));

		gl_PointSize=pixelRatio*pointSize*(1.+gas*2.)/length(mvPosition.xyz);
		gl_Position=projectionMatrix*mvPosition;
		//gl_PointSize=2.;
		//gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);
	}
</script>
<script id='fs' type='x-shader/x-fragment'>
	varying float blueColor;
	varying float gas;
	void main(){
		float ratio=distance(gl_PointCoord,vec2(.5));
		float gaslook=-(ratio-.5)*1.2*gas; 
		float starlook=(1.-gas)/(ratio*10.);
		float result=gaslook+starlook;
		gl_FragColor=vec4(.32,.28,blueColor,result)*result;
		//gl_FragColor=vec4(1.);
	}
</script>
<!-- end display shaders -->

<!-- init shaders -->
<script id='initvs' type='x-shader/x-vertex'>
	uniform float b;
	attribute vec3 initPos;
	attribute vec3 initSpeed;
	varying vec3 vColor;
	void main(){
		vColor=b==0.?initSpeed:initPos;
		gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);
	}
</script>
<script id='initfs' type='x-shader/x-fragment'>
	varying vec3 vColor;
	void main(){
		gl_FragColor=vec4(vColor,1.);
	}
</script>
<!-- end init shaders -->


<!-- generic vertex shader -->
<script id='gvs' type='x-shader/x-vertex'>
	varying vec3 vPosition;
	void main(){
		vPosition=position;
		gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);
	}
</script>
<!-- end generic vertex shader -->


<!-- position shader -->
<script id='ps' type='x-shader/x-vertex'>
	uniform sampler2D posTex;
	uniform sampler2D speedTex;
	varying vec3 vPosition;
	void main(){
		vec3 pos=texture2D(posTex,vPosition.xy).xyz;
		vec3 speed=texture2D(speedTex,vPosition.xy).xyz;
		pos+=speed;
		gl_FragColor=vec4(pos,1.);
	}
</script>
<!-- end position shader -->


<!-- speed shader -->
<script id='ss' type='x-shader/x-vertex'>
	precision highp float;
	uniform sampler2D posTex;
	uniform sampler2D speedTex;
	uniform float size;
	varying vec3 vPosition;
	const float pix=1./32.;
	void main(){
		vec3 speed=texture2D(speedTex,vPosition.xy).xyz;
		vec3 pos=texture2D(posTex,vPosition.xy).xyz;
		for(float i=0.;i<1.;i+=pix){
			for(float j=1.;j>0.;j-=pix){
				vec3 v=texture2D(posTex,vec2(i,j)).xyz-pos;
				float d=length(v);
				if(d>0.)speed+=.0001*v/(d*d);
			}
		}
		gl_FragColor=vec4(speed,1.);
	}
</script>
<!-- end speed shader -->

<script>
	'use strict';
	
	var scene,renderer,camera,controls,points;
	var texGeometry,texturesScene,orthoCam;
	var speedTex=[],posTex=[],
		speedMesh,posMesh,
		actual=1,before=(actual+1)%2;
	var rtParams={
			format:THREE.RGBFormat,
			generateMipmaps:false,
			magFilter:THREE.NearestFilter,
			minFilter:THREE.NearestFilter,
			type:THREE.FloatType
		};
	var size=32;
	var galaxy=new Galaxy(size*size);
	
	setScenes();

	addPoints();

	animate();

	function setScenes(){
		//main scene & usual stuff
		renderer=new THREE.WebGLRenderer();
		renderer.setSize(innerWidth,innerHeight);
		document.body.appendChild(renderer.domElement);
		scene=new THREE.Scene();
		camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,100,100000);
		camera.position.z=200;
		controls=new THREE.TrackballControls(camera,renderer.domElement);
		controls.rotateSpeed=7;

		//texturesScene
		texturesScene=new THREE.Scene();
		orthoCam=new THREE.OrthographicCamera(0,1,1,0,.1,1);
		orthoCam.position.z=1;
		orthoCam.lookAt(scene.position);

		initRT();
		initTextures();

		//scene.add(new THREE.AxisHelper(size/2));
	}

	function addPoints(){
		var geometry=new THREE.Geometry();
		for(var i=0;i<size*size;i++)geometry.vertices.push(new THREE.Vector3(i%size/size+.5/size,-Math.floor(i/size)/size+1-.5/size,0));

		var material=new THREE.ShaderMaterial({
			vertexShader:document.getElementById('vs').textContent,
			fragmentShader:document.getElementById('fs').textContent,
			uniforms:{
				posTex:{type:'t',value:posTex[actual]},
				pointSize:{type:'f',value:400/size},
				pixelRatio:{type:"f",value:innerHeight}
			},
			transparent:true,
			depthTest:false,
			blending:THREE.AdditiveBlending
		})

		points=new THREE.Points(geometry,material);

		scene.add(points);
	}

	function initRT(){
		speedTex[0]=new THREE.WebGLRenderTarget(size,size,rtParams);
		speedTex[1]=new THREE.WebGLRenderTarget(size,size,rtParams);
		posTex[0]=new THREE.WebGLRenderTarget(size,size,rtParams);
		posTex[1]=new THREE.WebGLRenderTarget(size,size,rtParams);
	}

	function setTexGeometry(){
		texGeometry=new THREE.BufferGeometry();
		var vertices=new Float32Array(size*size*3*6);
		var initPos=new Float32Array(size*size*3*6);
		var initSpeed=new Float32Array(size*size*3*6);
		var starsInitPos=galaxy.getPos();
		var starsInitSpeed=galaxy.getSpeed();
		for(var i=0;i<size*size;i++){
			var a=i%size/size,
				b=-Math.floor(i/size)/size+1;
			//top triangle
			//top left				    //bottom left			 	 //top right
			vertices[18*i]=a;			vertices[18*i+3]=a;		 	 vertices[18*i+6]=a+1/size;
			vertices[18*i+1]=b;			vertices[18*i+4]=b-1/size;	 vertices[18*i+7]=b;
			vertices[18*i+2]=0;			vertices[18*i+5]=0;		 	 vertices[18*i+8]=0;
			
			//bottom triangle
			//top right				    //bottom left			 	 //bottom right
			vertices[18*i+9]=a+1/size;	vertices[18*i+12]=a;	 	 vertices[18*i+15]=a+1/size;
			vertices[18*i+10]=b;		vertices[18*i+13]=b-1/size;	 vertices[18*i+16]=b-1/size;
			vertices[18*i+11]=0;		vertices[18*i+14]=0;	 	 vertices[18*i+17]=0;

			initPos[18*i]=initPos[18*i+3]=initPos[18*i+6]=initPos[18*i+9]=initPos[18*i+12]=initPos[18*i+15]=starsInitPos[3*i];
			initPos[18*i+1]=initPos[18*i+4]=initPos[18*i+7]=initPos[18*i+10]=initPos[18*i+13]=initPos[18*i+16]=starsInitPos[3*i+1];
			initPos[18*i+2]=initPos[18*i+5]=initPos[18*i+8]=initPos[18*i+11]=initPos[18*i+14]=initPos[18*i+17]=starsInitPos[3*i+2];

			initSpeed[18*i]=initSpeed[18*i+3]=initSpeed[18*i+6]=initSpeed[18*i+9]=initSpeed[18*i+12]=initSpeed[18*i+15]=starsInitSpeed[3*i+0];		
			initSpeed[18*i+1]=initSpeed[18*i+4]=initSpeed[18*i+7]=initSpeed[18*i+10]=initSpeed[18*i+13]=initSpeed[18*i+16]=starsInitSpeed[3*i+1];
			initSpeed[18*i+2]=initSpeed[18*i+5]=initSpeed[18*i+8]=initSpeed[18*i+11]=initSpeed[18*i+14]=initSpeed[18*i+17]=starsInitSpeed[3*i+2];
		}
		texGeometry.addAttribute('position',new THREE.BufferAttribute(vertices,3));
		texGeometry.addAttribute('initPos',new THREE.BufferAttribute(initPos,3));
		texGeometry.addAttribute('initSpeed',new THREE.BufferAttribute(initSpeed,3));
	}

	function setInitPosSpeed(){
		var initTexMaterial=new THREE.ShaderMaterial({
			vertexShader:document.getElementById('initvs').textContent,
			fragmentShader:document.getElementById('initfs').textContent,
			uniforms:{
				b:{type:'f',value:0}
			}
		});

		var initTexMesh=new THREE.Mesh(texGeometry,initTexMaterial);

		texturesScene.add(initTexMesh);

		renderer.render(texturesScene,orthoCam,speedTex[actual]);
		initTexMesh.material.uniforms.b.value=1;
		renderer.render(texturesScene,orthoCam,posTex[actual]);

		texturesScene.remove(initTexMesh);
		//scene.add(initTexMesh)
	}

	function initTextures(){
		setTexGeometry();
		setInitPosSpeed();

		var posMaterial=new THREE.ShaderMaterial({
			vertexShader:document.getElementById('gvs').textContent,
			fragmentShader:document.getElementById('ps').textContent,
				uniforms:{
					posTex:{type:'t',value:null},
					speedTex:{type:'t',value:null}
				}
		});
		var speedMaterial=new THREE.ShaderMaterial({
			vertexShader:document.getElementById('gvs').textContent,
			fragmentShader:document.getElementById('ss').textContent,
				uniforms:{
					posTex:{type:'t',value:null},
					speedTex:{type:'t',value:null},
					size:{type:'f',value:size}
				}
		});

		speedMesh=new THREE.Mesh(texGeometry,speedMaterial);
		posMesh=new THREE.Mesh(texGeometry,posMaterial);
		//computePositions();
		//scene.add(posMesh,speedMesh)
		//speedMesh.position.x+=1;
	}

	function animate(){
		requestAnimationFrame(animate);
		renderer.render(scene,camera);
		points.material.uniforms.posTex.value=computePositions();
		controls.update();
	}

	function computePositions(){
		before=actual;
		actual=(actual+1)%2;

		texturesScene.add(speedMesh);
		speedMesh.material.uniforms.speedTex.value=speedTex[before];
		speedMesh.material.uniforms.posTex.value=posTex[before];
		renderer.render(texturesScene,orthoCam,speedTex[actual])
		texturesScene.remove(speedMesh);

		texturesScene.add(posMesh);
		posMesh.material.uniforms.speedTex.value=speedTex[actual];
		posMesh.material.uniforms.posTex.value=posTex[before];
		renderer.render(texturesScene,orthoCam,posTex[actual])
		texturesScene.remove(posMesh);

		return posTex[actual];
	}

	function Galaxy(_n, _axis1, _axis2, _armsAngle, _bulbSize, _ellipticity){
		var n=(typeof _n === 'undefined')?10000:_n;
		var axis1=(typeof _axis1 === 'undefined')?75:_axis1;
		var axis2=(typeof _axis2 === 'undefined')?(axis1+30+Math.random()*30):_axis2;
		var maja,mina;
		axis1>axis2?(maja=axis1,mina=axis2):axis1==axis2?(maja=axis1+1,mina=axis2):(maja=axis2,mina=axis1);
		var armsAngle;
		if(typeof _armsAngle === 'undefined'){
			var b=(Math.random()*2-1)>0?1:-1;
			armsAngle=b*(Math.random()*6+3);
		}else{armsAngle=_armsAngle}
		var bulbSize=(typeof _bulbSize === 'undefined')?.3:_bulbSize>1?1:_bulbSize<0?0:_bulbSize;
		var ellipticity=(typeof _ellipticity === 'undefined')?.2+Math.random()*.2:_ellipticity>1?1:_ellipticity<0?0:_ellipticity;
		
		var starsPos=[],starsSpeeds=[],dist,angle,a,b,e,phi,theta,radius;
		for(var i=0;i<n;i++){
			dist=Math.random();
			angle=(dist-bulbSize)*armsAngle;
			a=maja*dist;
			b=mina*dist;
			e=Math.sqrt(a*a-b*b)/a;
			phi=ellipticity*Math.PI/2*(1-dist)*(Math.random()*2-1);
			theta=Math.random()*Math.PI*2;
			radius=Math.sqrt(b*b/(1-e*e*Math.pow(Math.cos(theta),2)))*(1+Math.random()*.1);
			if(dist>bulbSize)theta+=angle;

			var pos=new THREE.Vector3(
				Math.cos(phi)*Math.cos(theta)*radius,
				Math.cos(phi)*Math.sin(theta)*radius,
				Math.sin(phi)*radius);
			starsPos.push(pos.x,pos.y,pos.z);

			var c=Math.sqrt(pos.length()),
				speedCoeff=.0337,//make it related to the one in the shader
				arms=armsAngle>0?1:-1;
			pos.normalize();
			var speed=new THREE.Vector3().crossVectors(pos,new THREE.Vector3(0,0,1));
			speed.multiplyScalar(speedCoeff*c*arms);
			starsSpeeds.push(speed.x,speed.y,speed.z)
		}
		console.log(axis1+ ' ' +axis2+ ' ' + armsAngle + ' ' + bulbSize + ' ' + ellipticity )
		this.getPos=function(){
			return starsPos;
		};
		this.getSpeed=function(){
			return starsSpeeds;
		};
	}
</script>
</body>
</html>