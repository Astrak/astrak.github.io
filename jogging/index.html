<!Doctype html>
<html>
	<head>
		<title>How do you run ?</title>
		<script src=../libs/threer72.js></script>
		<script src=../libs/controls/OrbitControls.js></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js'></script>
		<style>
			body{
			    margin:0;
			    overflow:hidden;
			}
			canvas{
				cursor:grab;
				cursor:-webkit-grab;
				cursor:-moz-grab;
			}
			canvas:active{
				cursor:grabbing;
				cursor:-webkit-grabbing;
				cursor:-moz-grabbing;
			}
			button,input{
			    font:normal 30px Impact;
			    border-radius:10px 10px 0px 0px;
			    border:solid 1px darkslategrey;
			    outline:0;
			    position:absolute;
			    bottom:0;
			    width:150px;
			    height:60px;
			    left:50%;
			    margin-left:-75px;
			    color:chocolate;
			    cursor:pointer;
			    letter-spacing:1px;
			    transition:all 200ms ease;
			    background:darkslategrey;
			 	-webkit-appearance: none; 
			}
			button:hover{
			    letter-spacing:3px;
			    border:solid 1px chocolate;
			}
			input{
				bottom:70px;
				background:none;
				border:none;
			}
			.adjust{
				left:150px;
				width:200px;
			}

			/**********************************/
			/** SLIDER STYLE FROM CSS TRICKS **/
			/**********************************/

			/** 1. REMOVE AUTOMATIC STYLES **/
			input[type=range]::-webkit-slider-thumb {
			  -webkit-appearance: none;
			}
			input[type=range]:focus {
			  outline: none;
			}
			input[type=range]::-ms-track {
			  cursor: pointer;
			  background: transparent; /* Hides the slider so custom styles can be added */
			  border-color: transparent;
			  color: transparent;
			}

			/** 2. THE THUMB **/
			input[type=range]::-webkit-slider-thumb {
			  -webkit-appearance: none;
			  height: 30px;
			  width: 30px;
			  border-radius: 50%;
			  background: chocolate;
			  margin-top: -11px; /* needed in Chrome, not in Firefox and IE */
			  box-shadow:2px 0px 3px #000;
			}
			input[type=range]::-moz-range-thumb {
			  height: 30px;
			  width: 30px;
			  border-radius: 50%;
			  background: chocolate;
			  box-shadow:2px 0px 3px #000;
			  border:none;
			}
			input[type=range]::-ms-thumb {
			  height: 30px;
			  width: 30px;
			  border-radius: 50%;
			  background: chocolate;
			  box-shadow:2px 0px 3px #000;
			  border:none;
			}

			/* 3. THE TRACK */
			input[type=range]::-webkit-slider-runnable-track {
			  width: 100%;
			  height: 8.4px;
			  background: darkslategrey;
			  border-radius: 1.3px;
			}
			input[type=range]:focus::-webkit-slider-runnable-track {
			  background: darkslategrey;
			}
			input[type=range]::-moz-range-track {
			  width: 100%;
			  height: 8.4px;
			  background: darkslategrey;
			  border-radius: 1.3px;
			}
			input[type=range]::-ms-track {
			  width: 100%;
			  height: 8.4px;
			  background: transparent;
			  border-color: transparent;
			  border-width: 16px 0;
			  color: transparent;
			}
			input[type=range]::-ms-fill-lower {
			  background: darkslategrey;
			  border-radius: 2.6px;
			}
			input[type=range]:focus::-ms-fill-lower {
			  background: darkslategrey;
			}
			input[type=range]::-ms-fill-upper {
			  background: darkslategrey;
			  border-radius: 2.6px;
			}
			input[type=range]:focus::-ms-fill-upper {
			  background: darkslategrey;
			}
		</style>
	</head>
	<body>
		<script>
			var renderer, scene, camera, controls, clock;
			var spot, plane, jogger, cycle, cycleLine, animation, slider, button;
			var othoCam1, orthoCam2, useScissor=false;
			var loader=new THREE.JSONLoader();
			var tl=new TimelineLite();
			var tween={width:0,width1:1,target:.72,opacity:0};

			loadModel();

			function loadModel(){
				loader.load('jogger_cyclearriere_footprint_low.json',function(geometry){
					setScene(geometry);
				});				
			}

			function setScene(geo){
				renderer=new THREE.WebGLRenderer();
				renderer.setSize(innerWidth,innerHeight);
				renderer.enableScissorTest(true);
				renderer.setViewport(0,0,innerWidth,innerHeight);
				renderer.setScissor(0,0,innerWidth,innerHeight);
				document.body.appendChild(renderer.domElement);

				scene=new THREE.Scene();

				clock=new THREE.Clock();

				//main cam
				camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.05,10);
				camera.position.set(1.3,1.3,1.6);
				camera.lookAt(0,tween.target);
				//side cam
				orthoCam1=new THREE.OrthographicCamera(-1,1,1,0,.1,3);
				orthoCam1.position.set(1,0,0);
				orthoCam1.lookAt(scene.position);
				//scene.add(new THREE.CameraHelper(orthoCam1));
				//bottom cam
				orthoCam2=new THREE.OrthographicCamera(-.25*innerWidth/innerHeight,.25*innerWidth/innerHeight,.4,-.4,.1,1);
				orthoCam2.position.set(0,-1,0);
				orthoCam2.up.set(0,0,1);
				orthoCam2.lookAt(scene.position);
				//scene.add(new THREE.CameraHelper(orthoCam2));

				controls=new THREE.OrbitControls(camera,renderer.domElement);
				controls.enablePan=false;
				controls.enableDamping=true;
				controls.dampingFactor=.05;
				controls.rotateSpeed=.07;
				controls.maxPolarAngle=1.9;
				//controls.enableZoom=false;
				controls.minDistance=1;controls.maxDistance=4;
				controls.target.set(0,tween.target,0);

				addPlane();
				addJogger(geo);

				setLighting();

				animate();

				window.addEventListener('resize',function(){
					//cams
					camera.aspect=tween.width1*innerWidth/innerHeight;
					camera.updateProjectionMatrix();
					orthoCam1.left=-tween.width*innerWidth/innerHeight;
					orthoCam1.right=tween.width*innerWidth/innerHeight;
					orthoCam1.updateProjectionMatrix();
					orthoCam2.left=-tween.width*innerWidth/innerHeight*.8;
					orthoCam2.right=tween.width*innerWidth/innerHeight*.8;
					orthoCam2.updateProjectionMatrix();
					//canvas and scissors
					renderer.setSize(innerWidth,innerHeight);
					renderer.setViewport(0,0,innerWidth,innerHeight);
					renderer.setScissor(0,0,innerWidth,innerHeight);
				},false)
			}
			
			function setLighting(){
				spot=new THREE.SpotLight(0xffffff,2,5);
				spot.position.set(-.2,3,.3);
				scene.add(spot);

				renderer.shadowMap.enabled=true;
				spot.castShadow=true;
				//spot.shadowCameraVisible=true;
				spot.shadowCameraFov=27;
				spot.shadowCameraNear=1.3;
				spot.shadowCameraFar=3.2;
				spot.shadowMapWidth=spot.shadowMapHeight=256;//above a new shadow appear that the bias cant correct

				spot.shadowBias=0.02;
				spot.shadowDarkness=.8;

				plane.receiveShadow=true;
				jogger.castShadow=true;	
			}

			function addPlane(){
				plane=new THREE.Mesh(
					new THREE.PlaneGeometry(5,5,20,20),
					new THREE.MeshLambertMaterial({
						color:0x2f4f4f,
						side:THREE.DoubleSide
					})
					);
				plane.rotation.x=-Math.PI/2;
				scene.add(plane);
			}

			function addJogger(geometry){
				var material=new THREE.MeshLambertMaterial({
						color:0xaa9944,
						skinning:true,
						emissive:0x554422
					});
				jogger=new THREE.SkinnedMesh(geometry,material);
				scene.add(jogger);
				
				loader.load('headmeshes.json',function(g){
					var hair=new THREE.Mesh(g,new THREE.MeshPhongMaterial({color:0x221a00,shininess:10}));
					jogger.skeleton.bones[62].add(hair);
					hair.position.y-=1.5981;
					hair.position.z+=.0127;
				});

				animation=new THREE.Animation(jogger,geometry.animations[0]);
				animation.interpolationType=THREE.AnimationHandler.CATMULLROM;
				animation.play();
				animation.timeScale=1.7;

				addCycleHelper(.01);
				setSpeedSlider();
				setViewsSwitcher();
			}

			function setSpeedSlider(){
				animation.timeScale=2.2;
				slider=document.createElement('input');
			    slider.type='range';
			    slider.min=-Math.abs(animation.timeScale);slider.max=Math.abs(animation.timeScale);slider.step=0.001;
			    slider.value=animation.timeScale;
			    document.body.appendChild(slider);

			    slider.addEventListener('input',function(){
					animation.timeScale=slider.value;			    	
			    },false);
			}

			function setViewsSwitcher(){
				button=document.createElement('button');
				button.innerHTML='analyse';
				document.body.appendChild(button);

				var update=function(){
					cycle.material.opacity=tween.opacity;
					controls.target.set(0,tween.target,0);
					camera.aspect=tween.width1*innerWidth/innerHeight;
					camera.updateProjectionMatrix();
					orthoCam1.left=-tween.width*innerWidth/innerHeight;
					orthoCam1.right=tween.width*innerWidth/innerHeight;
					orthoCam1.updateProjectionMatrix();
					orthoCam2.left=-tween.width*innerWidth/innerHeight*.8;
					orthoCam2.right=tween.width*innerWidth/innerHeight*.8;
					orthoCam2.updateProjectionMatrix();
				}

				tl.to(tween,1,{
					width1:.7,
					width:.3,
					target:.85,
					opacity:.6,
					ease:Power3.easeInOut,
					onUpdate:update
				}).pause();

				button.addEventListener('click',function(){
					var state=tl.progress();
					this.innerHTML=state<1?'< back':'analyse';
					state<1?tl.play():tl.reverse();
				});
			}

			function addCycleHelper(thickness){
				var b0=new THREE.Vector3();//hips
				var b1=new THREE.Vector3();//thigh
				var b2=new THREE.Vector3();//shin
				var b3=new THREE.Vector3();//foot
				var a=animation.data.hierarchy;
				var keyArray=[];
				for(var i=0;i<a[2].keys.length;i++){
					b0.set(a[0].keys[i].pos[0],a[0].keys[i].pos[1],a[0].keys[i].pos[2]);//no quat

			    	b1.set(a[1].keys[i].pos[0],a[1].keys[i].pos[1],a[1].keys[i].pos[2]);//no quat

			    	b2.set(a[2].keys[i].pos[0],a[2].keys[i].pos[1],a[2].keys[i].pos[2]);
			    	b2.applyQuaternion(a[1].keys[i].rot);//b1 quat
			    	
			    	b3.set(a[3].keys[i].pos[0],a[3].keys[i].pos[1],a[3].keys[i].pos[2]);
			    	b3.applyQuaternion(new THREE.Quaternion().copy(a[1].keys[i].rot).multiply(a[2].keys[i].rot));//b1 + b2 quat

					b3.add(b0).add(b1).add(b2);

					keyArray.push(new THREE.Vector3().copy(b3));
				}

				//transform the keyframes in a smooth curve
				var curve=new THREE.CatmullRomCurve3(keyArray);
				keyArray=curve.getPoints(50);

				//then the cycle
				//1. outer vertices and faces
				var g=new THREE.Geometry();
				for(var i=0;i<keyArray.length;i++){
					g.vertices.push(new THREE.Vector3().copy(keyArray[i]));
					keyArray[i].x*=-1;//enlarge the shape to the right foot
					g.vertices.push(keyArray[i]);
				}
				for(var i=0;i<keyArray.length-1;i++){
					g.faces.push(new THREE.Face3((i*2)%(2*keyArray.length),(i*2+1)%(2*keyArray.length),(i*2+2)%(2*keyArray.length)));
					g.faces.push(new THREE.Face3((i*2+1)%(2*keyArray.length),(i*2+3)%(2*keyArray.length),(i*2+2)%(2*keyArray.length)));
				}
				//2. inner vertices and inner plus side faces. 
				g.computeFaceNormals();//to compute vertexnormals
				g.computeVertexNormals();//so vertexNormals can be used to deduce inner vertices
				var normals=[];
				var l=g.vertices.length,fl=g.faces.length;
				for(var i=0;i<fl;i++){
					normals[g.faces[i].a]=g.faces[i].vertexNormals[0].negate();
					normals[g.faces[i].b]=g.faces[i].vertexNormals[1].negate();
					normals[g.faces[i].c]=g.faces[i].vertexNormals[2].negate();
				}
				for(var i=0;i<l;i++)g.vertices.push(new THREE.Vector3().copy(g.vertices[i]).add(normals[i].setLength(thickness)));
				for(var i=0;i<l;i++){
					//inner faces
					g.faces.push(new THREE.Face3((i)%l+l,(i+2)%l+l,(i+1)%l+l));
					g.faces.push(new THREE.Face3((i+1)%l+l,(i+2)%l+l,(i+3)%l+l));
					//side faces. TODO : debug those inner faces they create
					if(i%2===0){
						g.faces.push(new THREE.Face3(i,(i+2)%l,i+l));
						g.faces.push(new THREE.Face3(i+l,(i+2)%l,(i+2)%l+l));
					}else if(i%2===1){//change winding order on the other side for default THREE.FrontSide (transparency not great with double side)
						g.faces.push(new THREE.Face3(i,i+l,(i+2)%l));
						g.faces.push(new THREE.Face3(i+l,(i+2)%l+l,(i+2)%l));			
					}
				}
				cycle=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:0xd2691e,transparent:true,opacity:tween.opacity}));
				scene.add(cycle)
			}

			function animate(){
				requestAnimationFrame(animate);
				THREE.AnimationHandler.update(clock.getDelta());
				controls.update();
				render();
			}

			function render(){
				if(typeof jogger !== 'undefined' )jogger.material.emissive.set(0x554422);
				plane.material.emissive.set(0x000000);
				spot.shadowDarkness=.8;
				//main view
				renderer.setViewport(0,0,tween.width1*innerWidth,innerHeight);
				renderer.setScissor(0,0,(1-tween.width)*innerWidth,innerHeight);
				renderer.setClearColor(0x000000);
				renderer.render(scene,camera);
				if(tween.width>0){
					//side view
					renderer.setViewport((1-tween.width)*innerWidth,.5*innerHeight,tween.width*innerWidth,.5*innerHeight);
					renderer.setScissor((1-tween.width)*innerWidth,.5*innerHeight,tween.width*innerWidth,.5*innerHeight);
					renderer.setClearColor(0x333333);
					renderer.render(scene,orthoCam1);
					//bottom view
					if(typeof jogger !== 'undefined' )jogger.material.emissive.set(0xd2691e);
					spot.shadowDarkness=0;
					plane.material.emissive.set(0x222222);
					renderer.setViewport((1-tween.width)*innerWidth,0,tween.width*innerWidth,.5*innerHeight);
					renderer.setScissor((1-tween.width)*innerWidth,0,tween.width*innerWidth,.5*innerHeight);
					renderer.render(scene,orthoCam2);
				}
			}
		</script>
	</body>
</html>